package leetcode2018;

/**
 * @program: leetcode
 * @description:鸡蛋掉落
 *你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
 *
 * 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
 *
 * 你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
 *
 * 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
 *
 * 你的目标是确切地知道 F 的值是多少。
 *
 * 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
 *
 *
 *
 * 示例 1：
 *
 * 输入：K = 1, N = 2
 * 输出：2
 * 解释：
 * 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
 * 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
 * 如果它没碎，那么我们肯定知道 F = 2 。
 * 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
 * 示例 2：
 *
 * 输入：K = 2, N = 6
 * 输出：3
 * 示例 3：
 *
 * 输入：K = 3, N = 14
 * 输出：4
 * @author: jiaxin_feng
 * @create: 2019-09-24 17:34
 */
public class a_superEggDrop {
    public static void main(String[] args) {
        System.out.println(superEggDrop(1,2));
    }
    /**
     * f[k][n] 表示k个鸡蛋移动n步（测试n次）能检测出多少层？
     * 我们使用 f[k][step] 来表示在给定 k 个鸡蛋的前提下移动 step 步能确定的最大层数。接下来我们仔细一步步分析问题：
     * （1）dp[0][1] = 0：0个鸡蛋经过一步最大只能确定0层，这是初始条件
     * （2）dp[k][1] = 1：k个鸡蛋只移动一次只能确定1层，即在1层只需要放一次鸡蛋便知道当前的 F，碎了 F为0；没碎 F=1。
     * （3）dp[1][i] = i：即一个鸡蛋必须从第一层开始一个个试，为了确定 F 得试 i 次。
     * （4）dp[k][step] ：k个鸡蛋测试step次能测出来几层？
     * （
     * f[k][n] = f[k-1][n-1]+f[k][n-1]+1
     * k个鸡蛋移动n-1步能
     *
     * 换个思路
     *
     * 上面的方法的思路，都还是顺着题目的思路的进行的，其实我们可以换一个思路来想：“求k个鸡蛋在m步内可以测出多少层”。
     * 我们令dp[k][m]表示k个鸡蛋在m步内可以测出的最多的层数，那么当我们在第X层扔鸡蛋的时候，就有两种情况：
     *
     * 鸡蛋碎了，我们少了一颗鸡蛋，也用掉了一步，此时测出N - X + dp[k-1][m-1]层，X和它上面的N-X层已经通过这次扔鸡蛋确定大于F；
     * 鸡蛋没碎，鸡蛋的数量没有变，但是用掉了一步，剩余X + dp[k][m-1]，X层及其以下已经通过这次扔鸡蛋确定不会大于F；
     * 也就是说，我们每一次扔鸡蛋，不仅仅确定了下一次扔鸡蛋的楼层的方向，也确定了另一半楼层与F的大小关系，
     * 所以在下面的关键代码中，使用的不再是max，而是加法（这里是重点）。评论里有人问到为什么是相加，其实这里有一个惯性思维的误区，
     * 上面的诸多解法中，往往求max的思路是“两种方式中较大的那一个结果”，其实这里的相加，不是鸡蛋碎了和没碎两种情况的相加，
     * 而是“本次扔之后可能测出来的层数 + 本次扔之前已经测出来的层数”。
     * @param K 有k个鸡蛋，
     * @param N N层建筑
     * @return
     */
    public  static int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        for (int m = 1; m <= N; m++) {
            dp[0][m] = 0; // zero egg
            for (int k = 1; k <= K; k++) {
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
                if (dp[k][m] >= N) {
                    return m;
                }
            }
        }
        return N;
    }
}
